use bittorrent_starter_rust::torrent::Torrent; 
use bittorrent_starter_rust::torrent::calculate_info_hash_from_struct;
use hex;

#[test]
fn test_read_valid_torrent() {
	// println!("Current directory: {:?}", std::env::current_dir());
    let result = Torrent::from_file("tests/data/sample.torrent");
	assert!(result.is_ok());
}


#[test]
fn test_torrent_info_fields() {
    let torrent_result = Torrent::from_file("tests/data/sample.torrent");
    assert!(torrent_result.is_ok());

    let torrent = torrent_result.unwrap();

    let info_hash = calculate_info_hash_from_struct(&torrent.info);
    let info_hash_hex = hex::encode(info_hash);
    assert_eq!(
        info_hash_hex,
        "d69f91e6b2ae4c542468d1073a71d4ea13879a7f", 
        "info hash does not match expected"
    );

    assert_eq!(torrent.announce, "http://bittorrent-test-tracker.codecrafters.io/announce");
    assert_eq!(torrent.info.name, "sample.txt");
    assert_eq!(torrent.info.length, 92063);
    assert_eq!(torrent.info.piece_length, 32768);
    assert_eq!(torrent.info.pieces.len(), 3);

	let hashes = vec![
		"e876f67a2a8886e8f36b136726c30fa29703022d",
		"6e2275e604a0766656736e81ff10b55204ad8d35",
		"f00d937a0213df1982bc8d097227ad9e909acc17",
	];

	for (actual_piece, expected_hash) in torrent.info.pieces.iter().zip(hashes) {
        let actual_hex = hex::encode(actual_piece);
		assert_eq!(
			actual_hex, expected_hash, 
			"piece hash does not match expected"
		);
	}
}




